# Nodejs-start-w3school-alapj-n
A w3school feladatai átalakítva ES6-ra
Nodejs- backend
Most, hogy alaposan megismerkedtetek a html5 css3 és javascript alapjaival, további szintre lépthetünk. Eddig is láthattátok miért szükséges ezeket e a lépcsőfokokat betartani, mindeddig szükséges volt az előző lépcsőfok ismerete, ahhoz, hogy magabiztosan tudjunk tovább lépni.
Itt már abba nyertek betekintést, hogyan kell szerver oldali alkalmazásokat írni. Olyan szerveroldali programokat lehet írni, amelyek a kliens oldalról érkező adatot beolvassák, feldolgozzák, eltárolják és kiszolgálják. Ezzel a munkaerő piacon hasznos tudást szerezhetsz, amit ha szépen ötvözöl az eddigi front end ismereteiddel, alkalmassá fog tenni arra, hogy fullstack fejlesztőként tudj elhelyezkedni. 
Mi a nodejs?
NodeJs egy olyan futtató környezet, ami lehetőséget nyújt JavaScriptben írt programok futtatására szervereken. JavaScriptet leginkább a kliens oldalon szokták használni, a böngészőn keresztül. Ahhoz, hogy, megértsük miképp futtathatunk JavaScript kódot szerveren, először nézzük meg, miképp valósul meg ugyanez a böngészőn keresztül. A böngésző applikáció fejlesztők számára olyan motorokat kell biztosítani (a Google Chrome esetén a v8 engine), amik a JavaScript kódot gépi nyelvként interpretálják és le is futtatják. Alapvetően a NodeJs is ugyanazt a v8 engine-t használja, némi módosítással. Most felmerülhet bennünk az a kérdés, hogy miben jobb, mint a PHP, asp.net, stb. ? Annyi könnyebbséget nyújt, ha már dolgoztunk frontend oldalon, nem kell egy teljesen új nyelvet megtanulni ahhoz, hogy a backend-et is implementáljuk. Tehát ha valaki megtanulta a javascriptet, akkor nem kell új programnyelvet tanulnia ahhoz, hogy a szerver oldalon is tudjon programozni. Lényegében ugyanazokkal az eljárásokkal, függvényekkel, szintaxissal tudsz szerver oldali alkalmazást is írni. Tehát nagyon leegyszerűsítve ez a lényege.
A másik előnye az, hogy a non-blocking természetéből adódóan alkalmas egyszerre több ezer bejövő 'egyszerű' kérés kezelésére. A Node.js-t úgy írták meg, hogy (szinte) minden esemény aszinkron legyen, ezért az program sosem blokkolódik, azaz nem kell várni, hogy egy művelet befejeződjön, vele párhuzamosan futtathatunk további műveleteket. Ez pontosan ugyan úgy működik, mint a böngészőben levő XHR kérések, vagy más események, mint például a click, mouseover. Ez az alkalmazás folyamatosabb futását, több alkalmazás párhuzamosítását, valamint az egész rendszer optimálisabb működését teszi lehetővé. Tehát ebből is látszik, hogy másik nagy előnye az, hogy kezeli az eseményeket is más szerver oldali alkalmazásokkal szemben. 
A hétköznapi életben az egyik legelterjedtebb variáció, az Apache és php kombinációja. Ez úgy néz ki, hogy kap egy kérést az Apache szerver valahonnan, egy böngészőből a netről, 80-as porton. Amikor megkapja a kérést akkor megnézni, hogy hol van az erőforrás amit kértek, hol van az a honlap, és ha megtalálja, az „index.php” a kezdő fájl, akkor meghívja a php-t elindítja, a php legenerálja az oldal tartalmát neki, amikor végzett akkor vissza adja a vezérlést az Apache szervernek. Az Apache szerver lelövi a php-t kész vége a folyamatnak, leáll, és utána vissza küldi a tartalmat a kliens felé, és bontja a kapcsolatot. Tehát így néz ki egy http kérés. 
Érdekesség képpen, vizsgáljuk meg a „nodejs-org” oldalt, nyomjunk neki egy f12-t, kattintsunk a Network fülre, és itt ha egy f5-öt, ha nyomunk újra frissíti az oldalt, és itt látható hogy egy csomó kérést elküld a szerver felé az oldalunk, és látható, hogy mi az amit legelőször lekér, az a document, tehát mindig a legelső az a html váza az oldalnak, ami lejön a szerverről. ugye a html dokumentunk ezzel még sokat fogunk foglalkozni, az egy xml-ben htmlxml-ben írt dokumentum, rákattintva látható is a nyers váza az oldalnak, itt vannak leírva az alapvető scriptek stb. illetve egy csomó hivatkozást tartalmaz. A böngésző úgy dolgozik, hogy föntről lefelé elindul, teljesen egyszerűen, mint ahogyan az ember olvassa soronként elolvassa ezt a kódot, és amit ott talál azt végre hajtja. Először megnézi, hogy dokumentum típusa html, majd látja, hogy elindul a html-ünk, html nyitó tag, beállítja a nyelvet angolul, aztán jön fejrész, beállítja a karakterkódolást, majd a címet, beállítja a linkeket megy tovább. Utána talál egy scriptet lefutatja a scirptet, és amíg a scirpt nem futott le addig nem megy tovább, majd jön az oldalnak a body része amit mindenki lát, abban is van egy header, container, talál egy ilyet img src, az srcből tudja hogy ez egy külső erőforrás be kell olvasnunk, meghívja újra küld egy kérést a szerver felé, letölti a logo.svg fájlt, ha kész van megy tovább. Utána megkeresi a következő ilyen hivatkozást, és még sok minden más huncutság van itt sorról sorra és a végén van egy css fájl, ami gyakorlatilag az oldal megjelenését írja le, azt is lekéri, aztán látható benne webfont.js fáj, javascript fájl, aztán még jónéhány javascriptet lefuttat, és a végén kiszáll. Ez egy tipikus weboldal ebből a szempontból és ha a network fül alatt megnézzük, látható hány kérést küldött pl 14-et a szerver felé a böngészőnk, és azt is láthatjuk ezen kérések során, milyen mennyiségű fájlt mozgatott meg. Nem túl sok ha már be van cash-elve. 
Ezt azért néztük meg, mert a nodejs egy tipikusan szerver alkalmazás, kiszolgáló alkalmazás. Tehát ha mi nodejs-ben szeretnénk egy weblapot elkészíteni, akkor az összes kérést ami itt fel van sorolva mindet a nodejs-nek kell kiszolgálni. Elküldi a tartalmat a html-t kiszolgálja a fájlokat, vissza küldi a felhasználónak a kért fájlokat, összeállítja a tartalamat templatekből, minden egyes kérésnél beállítja a fejlécket, stb ezt mind mind a nodejs fogja kiszolgálni.  
Nincs külön szerveroldali nyelv mint a php, nincs külön szerver mint IS vagy apache, hanem a kettő egyben van. Tulajdonképpen mind a kettő a nodejs. A nodejs egy személyben ő szerver is és ő generálja a tartalmat is. A klasszikus megközelítés az volt, hogy mindig külön volt a szerver program és külön a kódgenerátor. Típustól függően microsoftos kódgenerátor php vagy bármi más, ami generálta a kódot, itt a kettő egyben van!
Hátránya, hogy mivel összetetetettebb kódot kell írni, könnyebb elrontani. Ugyanaz végzi a fájlkiszolgálást is meg a tartalom generálást is. 
Előnye, hogy lényegesen kisebb a processzor és a memória felhasználása. Miért, mert mindegy egyes folyamat amit fut a szerveren, ugyanúgy mint a windowson ha megnyitjuk a folyamat kezelőt, minden egyes folyamat foglal memóriát, processzor időt stb. Itt ebben az esetben nem kell két folyamatot futtatnia, külön a szervert külön a generátort, hanem egy folyamat fut csak, jellemzően olyan ötöde tizede a memória felhasználása, egy ugyanakkora oldanál egy nodejsnek mint pl az apache php kombónak. Ez egy nagyon nagy előny. Nem blokkolja az I/O modelt, 
Az oldalon láthatjuk le van írva angolul, hogy a nodejs egy eseményvezérelt rendszert használ, az input output modell tulajdonképpen a kapcsolódás és lekapcsolódás, amikor egy hagyományos szerver végez bontja  a kapcsolatot a felhasználóval. Viszont a nodejs-el meg tudjuk azt csinálni, hogy amikor kiszolgálta a felhasználó kérését utána kapcsolatban marad egy socketen keresztül a felhasználó gépével, és nem kell mindig minden kérésnél újra felépíteni a kapcsolatot, hanem a meglévő csatornán socketen keresztül tudnak kommunikálni egymással. (socket – konnektort jelent) tehát be van csatlakoztatva a konektorba a felhasználó és folyamatos a kapcsolat a két fél között. 
A Node.JS és a böngésző jelentősen különböznek egymástól, annak ellenére, hogy mindkettő a JavaScript nyelven alapszik. A node.js veszi az alap nyelvet, akárcsak bármelyik böngésző motor, és különböző API-kkal bővíti azt, ezzel lehetőséget nyújtva szerveroldali műveletekre, hálózati feladatok ellátására.
Először is nézzük meg, hogy a node.js milyen futtatási környezetben működik, és hogyan illeszkedik abba a rendszerbe, amivel már kliens oldali fejlesztőként találkoztatok. Ehhez nyugodtan elővehetjük azt a kis ábrát, amit a javascripttel való ismerkedés elején néztünk meg, ami bemutatja a http protkoll alapvető működését. 
Ismétlés: A böngészőben működik egy beépülő program, egy ún js engine vagy js motor, ez egy interpreter, amibe a bemenet a js nyelven írott kód, és amit ez csinál, az az, hogy vezérli a böngészőt. Ezt több módon is teszi, többek között az enginet a motort tudja vezérelni, tehát a html dokumentumot, tulajdonképpen megvan a motornak a hatalma arra, hogy elementeket hozzon létre, vagy bármely element bármely attribútumát módosítsa. Emellett hozzáférése van az ún console-hoz, ami egy interfész arra, hogy mi közvetlenül kommandokat tudjunk beküldeni az enginenek, és meg is tudjuk nézni azt, amit az engine vissza küld válaszként. A console-t sokat fogjuk használni. Emellett az enginenek megvan a hatalma arra, hogy ő maga küldjön ilyen http kéréseket, és a beérkező válaszokat feldolgozza, ezek az ún ajax kérések, és nagyon nagy szerepük van a kliens oldali alkalmazásokban. Emellett az enginen keresztül adatot is tudunk tárolni, létezik a böngészőnek egy local storage nevű szekciója, ahol elhelyezhetünk adatot és később akár újabb oldalletöltéssel kiolvashatunk minden adatot. Manapság már nemcsak a kliens oldalon működik javascript engine, hanem már megannyi futtatási környezetben használható ez a motor, többek között szerver oldalon is futtatható. Node.js programon keresztül is használható az engine, de ebben a kontextusban merőben eltérő feladatai vannak az enginennek, hiszen ő a kéréseket fogadja és ezekre válaszokat küld. Tehát célját és feladatait tekintve abszolút eltér a kliens oldalon használt engine-től. 
A kliens oldalon két fő feladata van a js—nek, egyrészt a html elementek módosítása révén elérhető egyfajta interakció fokozás, másrészről meg ajax kérések küldése révén tudunk oldal letöltés nélkül kis mennyiségű adatért folyamodni a szerver oldalra. Amennyiben maxra járatjuk a js kódot, a kliens oldalon létrehozhatunk olyan user interface-ket, amik oldal letöltés nélkül kommunikálnak folyamatosan a szerver oldalra és ilyen olyan interaktív hatásokat is hoznak létre tehát akár egy telefonos applikáció hatását is keltik, egy klasszikus értelemben vett weboldal hatását, ahol kattintgatunk és frissülnek az oldalak, tehát egy folyamatos smooth élményt egy megszakítás nélküli felhasználói élményt nyújtanak. 
Nézzük tovább, ha van egy szervered, akkor a nodejs program milyen feladatokat hivatott ott ellátni. Ha pl nodejs szervert üzemeltetsz a szerver elsődleges célja a http kéréseknek a fogadása, majd a kérés alapján egy http válasz megküldése. Most átülünk a rendszer másik oldalára, ahol a kéréseket fogadjuk, és a válaszokat küldjük. A szerverednek hozzáférése van a lokális gépednek a fájl rendszeréhez. Az előző képet egy kis dobozkával lehet kiegészíteni file system, ebbe a fájl rendszerbe a node js program tud írni, és tud belőle olvasni. Emellett a nodejs applikáció tipikusan kapcsolatba lép adatbázissal, ez által a rendszer alkalmassá válik klienstől kapott adat eltárolására, majd akár egy újabb beérkező request kapcsán az adat kiolvasására majd a válaszként való megküldésére. A két rendszer működése a való életben úgy néz ki, hogy teszem azt le akarod tölteni a portfolio.hu oldalát, ezért beírod url-nek, hogy portfolio.hu, és rányomsz az enterre. Ekkor a böngésző kiküld egy http kérést, a portfolio.hu szerverének, ezt a kérést a szerver egy adott portján keresztül fogadja, majd a fájl rendszeréből egy html sablont olvas be. Emellett az adatbázissal is kapcsolatba lép, és kiolvassa a napi legfrissebb híreket. A beolvasott html sablonból, valamint az adatbázisból származó információból össze állít, specifikus, arra az adott napra aktuálisan érvényes html dokumentumot. Ezt a dokumentumot megküldi válaszként a kliensnek. A böngésző ezután kirendereli a tartalmat, valamint hogyha a html tartalomban vannak hivatkozások, további erőforrásra, azokat a kéréseket kiküldi szintén szerver oldalra. Az adott esetben ilyen módon kiszolgált szerver oldali scriptek lefutnak a böngészőben. Amennyiben a html tartalomban vannak interaktív komponenesek, teszem azt megnézzük a tőzsdei információkat valós időben (itt 15 perces késéssel látjuk, valós időhoz előfizetés szükséges) szolgáltató interaktív komponenst, akkor az interaktivitást a szerverről megkapott kliens oldali script biztosítja, és ez a js kód folyamodhat friss tőzsdei adatokhoz, időként a szerverhez, tehát ő maga kiküldhet http kérést, miután az oldalt letöltöttük. Ebben az esetben ez a kérés szerver oldalon szintén beérkezik egy bizonyos portra. A nodjs a kérésnek megfelelő adatokat kiolvassa, majd ezt json formátumban küldi meg válaszként. A beérkező json tartalmat a js app kirendereli kliens oldalon, így egy folyamatosan frissülő tartalmat láthatunk. 
Amit fontos látnunk, hogy a szerver, amikor először letöltöttük az oldalt, még csak egy html tartalommal válaszolt, és ez volt az első dolog amit a kliens megkapott. Utána a kliens kért tőle képeket, scripteket, css fájlokat, majd amikor a script elkezdett futni, és ajax kérést küldött ki, akkor a szerver json tartalmat is szolgáltatott. Tehát a szerver sokfajta tartalom típus szolgáltatásért felelős. Ezeket fogjuk megnézni, hogy a különböző tartalom típusokra irányuló kéréseket, hogyan tudjuk teljesíteni, kiszolgálni, illetve hogyan tudjuk őket szerver oldalon kezelni. 

